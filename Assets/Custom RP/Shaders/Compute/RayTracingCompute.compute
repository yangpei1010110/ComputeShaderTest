// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTracingCompute

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "ComputeInput.hlsl"
#include "CreateCameraRays.hlsl"
#include "../Structs/RayIntersect.hlsl"

float3 Normal(float3 t0, float3 t1, float3 t2)
{
    return normalize(cross(t1 - t0, t2 - t0));
}

[numthreads(8,8,1)]
void RayTracingCompute(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = (id.xy + 0.5) / float2(width, height) * 2.0 - 1.0;
    Ray ray = CreateCameraRays(uv);
    Result[id.xy] = float4(ray.direction * 0.5 + 0.5, 1.0);

    // if (id.x * width + id.y < BvhTreeCount)
    float3 minDistance = FLT_MAX;
    // for (int i = 0; i < BvhTreeCount; i++)
    {
        // int index = id.x * width + id.y;
        // index %= BvhTreeCount;
        BvhNode node = BvhTree[i];
        float3 t0 = Vertices[Triangles[node.triangleIndex]];
        float3 t1 = Vertices[Triangles[node.triangleIndex + 1]];
        float3 t2 = Vertices[Triangles[node.triangleIndex + 2]];
        float3 distance;
        if (RayIntersectsTriangle(ray, t0, t1, t2, distance))
        {
            // RayIntersectsTriangle(ray, t0, t1, t2, distance);
            minDistance = min(minDistance, distance);
            // float3 normal = Normal(t0, t1, t2);
            Result[id.xy] = float4(minDistance, 1.0);
        }
    }
}
